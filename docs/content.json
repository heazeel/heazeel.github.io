{"pages":[],"posts":[{"title":"使用glob来匹配文件","text":"介绍glob.js 是JavaScript中glob的实现，使用minimatch库来匹配，能够实现shell的匹配模式。 语法单个星号概念：单个星号 * 用于匹配单个片段中的零个或多个字符。 示例： src/*.js 表示 src 目录下所有以 js 结尾的文件，但是不能匹配 src 子目录中的文件，例如 src/login/login.js /home/*/.bashrc 匹配所有用户的 .bashrc 文件需要注意的是，* 不能匹配分隔符/，也就是说不能跨片段匹配字符。 问号概念：问号 ?匹配单个片段中的单个字符。 示例： test/?at.js 匹配形如 test/cat.js、test/bat.js 等所有3个字符且后两位是 at 的 js 文件，但是不能匹配 test/flat.jssrc/index.?? 匹配 src 目录下以 index 打头，后缀名是两个字符的文件，例如可以匹配 src/index.js 和 src/index.md，但不能匹配 src/index.jsx中括号概念:同样是匹配单个片段中的单个字符，但是字符集只能从括号内选择，如果字符集内有-，表示范围。 示例： test/[bc]at.js 只能匹配test/bat.js 和 test/cat.jstest/[c-f]at.js 能匹配 test/cat.js、test/dat.js、test/eat.js 和test/fat.js惊叹号概念：表示取反，即排除那些去掉惊叹号之后能够匹配到的文件。示例： test/[!bc]at.js不能匹配 test/bat.js 和 test/cat.js，但是可以匹配 test/fat.js!test/tmp/**’ 排除 test/tmp 目录下的所有目录和文件扩展语法基础语法非常简单好记，但是功能非常局限，为了丰富 glob 的功能，衍生了下面三种扩展语法： 两个星号概念：两个星号** 可以跨片段匹配零个或多个字符，也就是说**是递归匹配所有文件和目录的，如果后面有分隔符，即 **/ 的话，则表示只递归匹配所有目录（不含隐藏目录）。 示例： /var/log/** 匹配 /var/log 目录下所有文件和文件夹，以及文件夹里面所有子文件和子文件夹/var/log//.log 匹配 /var/log 及其子目录下的所有以 .log 结尾的文件/home//.ssh//*.key 匹配所有用户的 .ssh 目录及其子目录内的以.key 结尾的文件大括号概念：匹配大括号内的所有模式，模式之间用逗号进行分隔，支持大括号嵌套，支持用.. 匹配连续的字符，即{start..end} 语法。 示例： a.{png,jp{,e}g} 匹配 a.png、a.jpg、a.jpeg{a..c}{1..2} 匹配 a1 a2 b1 b2 c1 c2注意：{} 与 [] 有一个很重要的区别：如果匹配的文件不存在，[]会失去模式的功能，变成一个单纯的字符串，而 {} 依然可以展开。 小括号概念：小括号必须跟在 ?、、+、@、! 后面使用，且小括号里面的内容是一组以 | 分隔符的模式集合，例如：abc|a?c|ac。 示例： ?(pattern|pattern|pattern)：匹配0次或1次给定的模式*(pattern|pattern|pattern):匹配0次或多次给定的模式+(pattern|pattern|pattern)：匹配1次或多次给定的模式@(pattern|pattern|pattern)：严格匹配给定的模式!(pattern|pattern|pattern)：匹配非给定的模式 作者：WEB前端含光链接：https://www.jianshu.com/p/d61654c355ef来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2022/03/01/%E4%BD%BF%E7%94%A8glob%E6%9D%A5%E5%8C%B9%E9%85%8D%E6%96%87%E4%BB%B6/"},{"title":"分治策略&amp;动态规划","text":"这期我从分治策略和动态规划两个角度出发来比较两种算法的异同点，同时分析常见的递归优化方案，包括记忆化搜索和尾递归， 然后引出动态规划是解决某些问题的最优方法。 概念开始前先介绍几个概念： 自顶向下，理解为从问题的终点向问题的起点解决 自底向上，理解为从问题的起点向问题的终点解决 最优子结构：当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质 重叠子问题：在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次 分治策略如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。 由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。 在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。 分治算法通常使用递归的方式来求解 特征： 规模如果很小，则很容易解决。 大问题可以分为若干规模小的相同问题。//即要求具有最优子结构性质 利用子问题的解，可以合并成该问题的解。 分解出的各个子问题相互独立，子问题不再包含公共子问题。 //不一定需要满足，可以有重叠 经典的分治递归例子：斐波那契数列看结构： 满足规模小，容易解决 -&gt; 1+1=2 1+2=3 满足最优子结构，具体看图 满足子问题的解可合成该问题的解 子问题有重复，不影响分治算法的使用，但是会影响效率 一般的递归写法： 123456789101112131415161718// 一般递归写法let count = 0;const fib = (n) =&gt; { console.trace() count++; if(n === 0 || n === 1){ return 1; } return fib(n-1) + fib(n - 2);};console.time(&quot;time&quot;);let res = fib(30);console.timeEnd(&quot;time&quot;);console.log('res:', res, 'count:', count); 这种方法的优势在于每一步都看得很明白，对于斐波那契数列的结构也很清晰，但不好的地方在于，时间复杂度非常高，达到指数级，只要n变大，就出现爆栈和超时的问题。 时间复杂度：O(2^n) (渐进上界)O(1.618^n) (紧渐进界 具体推演过程) 空间复杂度：O(1) 优化方式一：记忆化搜索在原本的斐波那契递归中，总会像如上图一样递归到最后再返回结果 其中，例如 以5为例，3往下的部分，就会被重复计算两次，2往下的部分会被重复计算3次。 我们使用memo来缓存每一次的结果，下次如果再解决同样的子问题，就可以直接拿来使用： 12345678910111213141516171819202122//记忆化搜索let count = 0;let memo = [];const fib_memo = (n) =&gt; { console.trace() count++; if(n === 0 || n === 1){ return 1; } if(!memo[n]){ memo[n] = fib_memo(n-1) + fib_memo(n - 2) } return memo[n];};console.time('time');let res = fib_memo(10);console.timeEnd('time')console.log('res:', res, 'count:', count); 时间复杂度：O(n) 空间复杂度：O(n) 虽然时间复杂度度大大降低了，但这仍然影响性能。 因为在程序调用一个函数时，栈中会分配一块空间来保存与这个调用相关的信息，每一个调用都会被当作是活跃的。栈上的那块存储空间称为活跃记录或者栈帧。 然后因为递归函数在调用的时候会不断的创建一个栈帧来保存上一个函数的调用信息，栈上的栈帧越来越多，就会导致爆栈 Maximum call stack size exceeded。 接下来的目的就是去优化函数的调用栈，下面介绍尾递归。 优化方式二：尾递归如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的 下面几种情况都不是尾递归： 123456789101112function fn() { return gn() + 10//调用之后又赋值}function fn() { gn()//没有return，或者说是return了undefined}function fn() { let gnn = gn(); return gnn//调用后还有操作} 当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。 编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。 通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。 123456789101112131415161718// 尾递归let count = 0;const fib_tail = (n, num = 1, sum = 1) =&gt; { console.trace() count++; if (n&lt;=1){ return sum; } return fib_tail(n-1, sum, num + sum);}console.time('time');let res = fib_tail(10);console.timeEnd('time')console.log('res:', res, 'count:', count); 时间复杂度： O(n)空间复杂度： O(1) 可以看到此时这个算法的效率已经非常高了，但这仍然不是最优解，因为存在函数的调用开销，下面开始介绍动态规划算法。 动态规划算法动态规划算法（Dynamic Programming）与分治算法相似，都是通过组合子问题的解来求解原问题的解。 但是两者之间也有很大区别：分治法将问题划分为互不相交的子问题，递归的求解子问题，再将他们的解组合起来求解原问题的解；与之相反，动态规划应用于子问题相互重叠的情况，在这种情况下，分治法还是会做很多重复的不必要的工作，他会反复求解那些公共的子问题，而动态规划算法则对相同的每个子问题只会求解一次，将其结果保存起来，避免一些不必要的计算工作 特征 大问题可以分为若干规模小的相同问题。//即要求具有最优子结构性质 子问题空间必须足够” 小 “，也就是说原问题递归求解时会重复相同的子问题，而不是一直生成新的子问题。 //即有重叠子问题 思考步骤： 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。(划分子问题) 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。(状态表示) 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。（子问题与下个子问题间的关系式） 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。（边界条件） 比如斐波那契数列：1 1 2 3 5 8 13 21 … ，求第n项的值 第一步：输入1，输出1；输入2，输出1；输入3，输出2，通过分析可知道第n项值等于第n-1和n-2项的和 第二步：最后一项为f(n)，两项分别为f(n-1)、f(n-2) 第三步：状态转移方程：dp(n) = dp(n-1) + dp(n-2) 第四步：边界条件为dp[1]=1, dp[2]=1 1234567891011121314151617181920// 不带缓存的dplet count = 0;const fib_dp_unmemo = (n) =&gt; { let dp = []; dp[0] = 0; dp[1] = 1; for(let i = 2; i &lt;= n; i++) { count++; dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n];}console.time('time')let res = fib_dp_unmemo(30)console.timeEnd('time')console.log('res:', res, 'count:', count); 此时时间复杂度为O(n), 空间复杂度为O(n)，这还不够优雅，因为空间消耗的也多 123456789101112131415// 带缓存的dpconst fib_dp_memo = (n) =&gt; { let front = 0; let back = 1; let res = 0; for(let i = 2; i &lt;= n; i++) { res = front + back; front = back; back = res; } return res;};let res = fib_dp_memo(30); 使用变量保存下一次循环需要的子问题结果，而不是保存全部结果，这样能大大减少内存 此时时间复杂度为O(n), 空间复杂度为O(1) 动态规划对比于尾递归，通过一次迭代得到结果，函数的调用开销减少了，同时时空间复杂度和尾递归相同，是解决这个问题的最优解！ 拓展leetcode 题号：198.打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统， 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 1 &lt;= nums.length &lt;= 1000 &lt;= nums[i] &lt;= 400 首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。 如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。 如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？ 对于第 k (k&gt;2) 间房屋，有两个选项： 偷窃第 k 间房屋，那么就不能偷窃第 k-1 间房屋，偷窃总金额为前 k-2 间房屋的最高总金额与第 k 间房屋的金额之和。 不偷窃第 k 间房屋，偷窃总金额为前 k-1 间房屋的最高总金额。 在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。 用 dp[i] 表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程： dp[i] = max(dp[i−2] + nums[i], dp[i−1]) 边界条件为：dp[0] = nums[0] //只有一间房屋，则偷窃该房屋dp[1] = max(nums[0], nums[1]) //只有两间房屋，选择其中金额较高的房屋进行偷窃 12345678910111213const rob = (nums) =&gt; { const len = nums.length; if(len == 0){ return 0; } const dp = new Array(len + 1); dp[0] = 0; dp[1] = nums[0]; for(let i = 2; i &lt;= len; i++) { dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]); } return dp[len];}; 还不够，进行空间优化 123456789101112131415const rob = (nums) =&gt; { const len = nums.length; if(len == 0){ return 0; } let front = 0; let back = nums[0]; let res = 0; for(let i = 2; i &lt;= len; i++) { res = Math.max(back, front + nums[i-1]); front = back; back = res; } return res;};","link":"/2021/09/22/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5&%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"antd动态主题","text":"零代码本地会保存一份antd全部样式变量的文件","link":"/2022/02/28/antd%E5%8A%A8%E6%80%81%E4%B8%BB%E9%A2%98/"},{"title":"antd table 滚动加载","text":"背景最近在工作中有一个列表的滚动加载功能需求，了解了一下发现antd的table是不支持滚动加载的，只有list支持。因为原来的业务代码是用table做的，为了不改变原来的代码，我打算自己写个table的滚动加载功能。 实现想要实现一个滚动加载，目标就是实现对table的滚动行为进行监听。第一个想法就是获取Table的dom，然后对可滚动的table-body添加一个监听事件，这里我们利用useRef来获取dom。出现问题了，会报错，ts提示我们不能将MutableRefObject这个类型传递到table的props中。 12345678const target = useRef(null);&lt;Table ref={target} dataSource={dataSource} columns={columns} loading={tableLoading} scroll={{ y: 200 }}/&gt; 既然Table不能传入ref，那在外面包一层div总行了吧，于是代码变成了这样 123456789const target = useRef(null);&lt;div ref={target}&gt; &lt;Table dataSource={dataSource} columns={columns} loading={tableLoading} scroll={{ y: 200 }} /&gt;&lt;/div&gt; 控制台打印一下target.current，可以获取dom对象，到这我们的第一步目的就达成了。 接下来我们在target.current中获取table-body的dom对象，并对table-body的滚动进行监听，然后通过条件crollHeight - scrollTop === clientHeight来判断滚动条是否滚到底了，滚到底了就去异步加载数据。完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import React, { useEffect, useState, useRef } from 'react';import { Table } from 'antd';const data = [ { key: '1', name: '胡彦斌', age: 1, address: '西湖区湖底公园1号', }, { key: '2', name: '胡彦祖', age: 2, address: '西湖区湖底公园1号', }, { key: '3', name: '胡彦斌', age: 3, address: '西湖区湖底公园1号', }, { key: '4', name: '胡彦祖', age: 4, address: '西湖区湖底公园1号', }, { key: '5', name: '胡彦斌', age: 5, address: '西湖区湖底公园1号', }, { key: '6', name: '胡彦祖', age: 6, address: '西湖区湖底公园1号', },];const columns = [ { title: '姓名', dataIndex: 'name', key: 'name', }, { title: '年龄', dataIndex: 'age', key: 'age', }, { title: '住址', dataIndex: 'address', key: 'address', },];const ScrollTable = () =&gt; { const [dataSource, setDataSource] = useState(data); const [tableLoading, setTableLoading] = useState(false); const target = useRef(null); useEffect(() =&gt; { const dom = (target.current as HTMLElement | null)?.querySelector( '.ant-table-body', ) as HTMLElement; dom.addEventListener('scroll', () =&gt; scrollEvent()); return () =&gt; { dom.removeEventListener('scroll', scrollEvent); }; }, []); const scrollEvent = () =&gt; { const dom = (target.current as HTMLElement | null)?.querySelector( '.ant-table-body', ) as HTMLElement; if (dom.scrollHeight - dom.scrollTop === dom.clientHeight) { // 在这里去获取并更新数据 setTableLoading(true); setTimeout(() =&gt; { console.log('已滚动到底部'); let arr: any = []; setDataSource(arr); setTableLoading(false); }, 1000); } }; return ( &lt;div ref={target} style={{ width: '70%', margin: 'auto', paddingTop: '100px' }} &gt; &lt;Table dataSource={dataSource} columns={columns} loading={tableLoading} scroll={{ y: 200 }} /&gt; &lt;/div&gt; );};export default ScrollTable;","link":"/2021/09/22/antd%20table%20%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD/"},{"title":"手写call和apply","text":"原文链接 一句话介绍 call：call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 举个例子： 123456789var foo = { value: 1};function bar() { console.log(this.value);}bar.call(foo); // 1 注意两点： call 改变了 this 的指向，指向到 foo bar 函数执行了 模拟实现第一步那么我们该怎么模拟实现这两个效果呢？ 试想当调用 call 的时候，把 foo 对象改造成如下： 12345678var foo = { value: 1, bar: function() { console.log(this.value) }};foo.bar(); // 1 这个时候 this 就指向了 foo，是不是很简单呢？ 但是这样却给 foo 对象本身添加了一个属性，这可不行呐！ 不过也不用担心，我们用 delete 再删除它不就好了~ 所以我们模拟的步骤可以分为： 将函数设为对象的属性 执行该函数 删除该函数 以上个例子为例，就是： 123456// 第一步foo.fn = bar// 第二步foo.fn()// 第三步delete foo.fn fn 是对象的属性名，反正最后也要删除它，所以起成什么都无所谓。 根据这个思路，我们可以尝试着去写第一版的 call2 函数： 123456789101112131415161718// 第一版Function.prototype.call2 = function(context) { // 首先要获取调用call的函数，用this可以获取 context.fn = this; context.fn(); delete context.fn;}// 测试一下var foo = { value: 1};function bar() { console.log(this.value);}bar.call2(foo); // 1 正好可以打印 1 哎！是不是很开心！(～￣▽￣)～ 模拟实现第二步最一开始也讲了，call 函数还能给定参数执行函数。举个例子： 1234567891011121314var foo = { value: 1};function bar(name, age) { console.log(name) console.log(age) console.log(this.value);}bar.call(foo, 'kevin', 18);// kevin// 18// 1 注意：传入的参数并不确定，这可咋办？ 不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。 比如这样： 1234567891011121314// 以上个例子为例，此时的arguments为：// arguments = {// 0: foo,// 1: 'kevin',// 2: 18,// length: 3// }// 因为arguments是类数组对象，所以可以用for循环var args = [];for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push('arguments[' + i + ']');}// 执行后 args为 [&quot;arguments[1]&quot;, &quot;arguments[2]&quot;, &quot;arguments[3]&quot;] 不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。 1234// 将数组里的元素作为多个参数放进函数的形参里context.fn(args.join(','))// (O_o)??// 这个方法肯定是不行的啦！！！ 也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到ES6的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样： 1eval('context.fn(' + args +')') 这里 args 会自动调用 Array.toString() 这个方法。 所以我们的第二版克服了两个大问题，代码如下： 1234567891011121314151617181920212223242526// 第二版Function.prototype.call2 = function(context) { context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push('arguments[' + i + ']'); } eval('context.fn(' + args +')'); delete context.fn;}// 测试一下var foo = { value: 1};function bar(name, age) { console.log(name) console.log(age) console.log(this.value);}bar.call2(foo, 'kevin', 18); // kevin// 18// 1 (๑•̀ㅂ•́)و✧ 模拟实现第三步模拟代码已经完成 80%，还有两个小点要注意： this 参数可以传 null，当为 null 的时候，视为指向 window 举个例子： 1234567var value = 1;function bar() { console.log(this.value);}bar.call(null); // 1 虽然这个例子本身不使用 call，结果依然一样。 函数是可以有返回值的！ 举个例子： 123456789101112131415161718var obj = { value: 1}function bar(name, age) { return { value: this.value, name: name, age: age }}console.log(bar.call(obj, 'kevin', 18));// Object {// value: 1,// name: 'kevin',// age: 18// } 不过都很好解决，让我们直接看第三版也就是最后一版的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// 第三版Function.prototype.call2 = function (context) { var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push('arguments[' + i + ']'); } var result = eval('context.fn(' + args +')'); delete context.fn return result;}// 测试一下var value = 2;var obj = { value: 1}function bar(name, age) { console.log(this.value); return { value: this.value, name: name, age: age }}bar.call2(null); // 2console.log(bar.call2(obj, 'kevin', 18));// 1// Object {// value: 1,// name: 'kevin',// age: 18// } 到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣▽￣）ｄ 代码有点老了，用ES6语法再完善一下吧1234567891011Function.prototype.call2 = function (context, ...args) { if (context == null) target = globalThis; if (typeof context !== 'object') context = Object(context); const symbol = Symbol(); context[symbol] = this; try { return context[symbol](...args); } finally { delete context[symbol]; }} apply的模拟实现apply 的实现跟 call 类似，在这里直接给代码: 12345678910111213141516171819Function.prototype.apply = function (context, arr) { var context = Object(context) || window; context.fn = this; var result; if (!arr) { result = context.fn(); } else { var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) { args.push('arr[' + i + ']'); } result = eval('context.fn(' + args + ')') } delete context.fn return result;}","link":"/2022/11/11/%E6%89%8B%E5%86%99call%E5%92%8Capply/"},{"title":"手写bind","text":"一句话介绍 bindbind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 由此我们可以首先得出 bind 函数的两个特点： 返回一个函数 h可以传入参数","link":"/2022/11/11/%E6%89%8B%E5%86%99bind/"},{"title":"DNS域名解析全过程","text":"目的将域名地址解析成可以访问的ip地址 流程输入网址 ↓浏览器缓存 ↓本地DNS缓存 ↓LDNS(本地域名服务器) ↓Root Server(根域名服务器) ↓返回主域名服务器地址（gTLD Server，国际顶尖域名服务器，如.com .cn .org等） ↓LDNS请求gTLD，返回Name Server域名服务器地址 ↓Name Server根据映射关系返回ip地址给LDNS ↓LDNS缓存域名和ip，返回结果给用户 ↓用户侧缓存域名和ip ↓解析结束","link":"/2022/11/27/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%85%A8%E8%BF%87%E7%A8%8B/"}],"tags":[],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"业务","slug":"业务","link":"/categories/%E4%B8%9A%E5%8A%A1/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"手写源码","slug":"手写源码","link":"/categories/%E6%89%8B%E5%86%99%E6%BA%90%E7%A0%81/"},{"name":"网络","slug":"网络","link":"/categories/%E7%BD%91%E7%BB%9C/"}]}