{"pages":[],"posts":[{"title":"使用glob来匹配文件","text":"介绍glob.js 是JavaScript中glob的实现，使用minimatch库来匹配，能够实现shell的匹配模式。 语法单个星号概念：单个星号 * 用于匹配单个片段中的零个或多个字符。 示例： src/*.js 表示 src 目录下所有以 js 结尾的文件，但是不能匹配 src 子目录中的文件，例如 src/login/login.js /home/*/.bashrc 匹配所有用户的 .bashrc 文件需要注意的是，* 不能匹配分隔符/，也就是说不能跨片段匹配字符。 问号概念：问号 ?匹配单个片段中的单个字符。 示例： test/?at.js 匹配形如 test/cat.js、test/bat.js 等所有3个字符且后两位是 at 的 js 文件，但是不能匹配 test/flat.jssrc/index.?? 匹配 src 目录下以 index 打头，后缀名是两个字符的文件，例如可以匹配 src/index.js 和 src/index.md，但不能匹配 src/index.jsx中括号概念:同样是匹配单个片段中的单个字符，但是字符集只能从括号内选择，如果字符集内有-，表示范围。 示例： test/[bc]at.js 只能匹配test/bat.js 和 test/cat.jstest/[c-f]at.js 能匹配 test/cat.js、test/dat.js、test/eat.js 和test/fat.js惊叹号概念：表示取反，即排除那些去掉惊叹号之后能够匹配到的文件。示例： test/[!bc]at.js不能匹配 test/bat.js 和 test/cat.js，但是可以匹配 test/fat.js!test/tmp/**’ 排除 test/tmp 目录下的所有目录和文件扩展语法基础语法非常简单好记，但是功能非常局限，为了丰富 glob 的功能，衍生了下面三种扩展语法： 两个星号概念：两个星号** 可以跨片段匹配零个或多个字符，也就是说**是递归匹配所有文件和目录的，如果后面有分隔符，即 **/ 的话，则表示只递归匹配所有目录（不含隐藏目录）。 示例： /var/log/** 匹配 /var/log 目录下所有文件和文件夹，以及文件夹里面所有子文件和子文件夹/var/log//.log 匹配 /var/log 及其子目录下的所有以 .log 结尾的文件/home//.ssh//*.key 匹配所有用户的 .ssh 目录及其子目录内的以.key 结尾的文件大括号概念：匹配大括号内的所有模式，模式之间用逗号进行分隔，支持大括号嵌套，支持用.. 匹配连续的字符，即{start..end} 语法。 示例： a.{png,jp{,e}g} 匹配 a.png、a.jpg、a.jpeg{a..c}{1..2} 匹配 a1 a2 b1 b2 c1 c2注意：{} 与 [] 有一个很重要的区别：如果匹配的文件不存在，[]会失去模式的功能，变成一个单纯的字符串，而 {} 依然可以展开。 小括号概念：小括号必须跟在 ?、、+、@、! 后面使用，且小括号里面的内容是一组以 | 分隔符的模式集合，例如：abc|a?c|ac。 示例： ?(pattern|pattern|pattern)：匹配0次或1次给定的模式*(pattern|pattern|pattern):匹配0次或多次给定的模式+(pattern|pattern|pattern)：匹配1次或多次给定的模式@(pattern|pattern|pattern)：严格匹配给定的模式!(pattern|pattern|pattern)：匹配非给定的模式 作者：WEB前端含光链接：https://www.jianshu.com/p/d61654c355ef来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2022/03/01/%E4%BD%BF%E7%94%A8glob%E6%9D%A5%E5%8C%B9%E9%85%8D%E6%96%87%E4%BB%B6/"},{"title":"分治策略&amp;动态规划","text":"这期我从分治策略和动态规划两个角度出发来比较两种算法的异同点，同时分析常见的递归优化方案，包括记忆化搜索和尾递归， 然后引出动态规划是解决某些问题的最优方法。 概念开始前先介绍几个概念： 自顶向下，理解为从问题的终点向问题的起点解决 自底向上，理解为从问题的起点向问题的终点解决 最优子结构：当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质 重叠子问题：在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次 分治策略如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。 由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。 在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。 分治算法通常使用递归的方式来求解 特征： 规模如果很小，则很容易解决。 大问题可以分为若干规模小的相同问题。//即要求具有最优子结构性质 利用子问题的解，可以合并成该问题的解。 分解出的各个子问题相互独立，子问题不再包含公共子问题。 //不一定需要满足，可以有重叠 经典的分治递归例子：斐波那契数列看结构： 满足规模小，容易解决 -&gt; 1+1=2 1+2=3 满足最优子结构，具体看图 满足子问题的解可合成该问题的解 子问题有重复，不影响分治算法的使用，但是会影响效率 一般的递归写法： 123456789101112131415161718// 一般递归写法let count = 0;const fib = (n) =&gt; { console.trace() count++; if(n === 0 || n === 1){ return 1; } return fib(n-1) + fib(n - 2);};console.time(&quot;time&quot;);let res = fib(30);console.timeEnd(&quot;time&quot;);console.log('res:', res, 'count:', count); 这种方法的优势在于每一步都看得很明白，对于斐波那契数列的结构也很清晰，但不好的地方在于，时间复杂度非常高，达到指数级，只要n变大，就出现爆栈和超时的问题。 时间复杂度：O(2^n) (渐进上界)O(1.618^n) (紧渐进界 具体推演过程) 空间复杂度：O(1) 优化方式一：记忆化搜索在原本的斐波那契递归中，总会像如上图一样递归到最后再返回结果 其中，例如 以5为例，3往下的部分，就会被重复计算两次，2往下的部分会被重复计算3次。 我们使用memo来缓存每一次的结果，下次如果再解决同样的子问题，就可以直接拿来使用： 12345678910111213141516171819202122//记忆化搜索let count = 0;let memo = [];const fib_memo = (n) =&gt; { console.trace() count++; if(n === 0 || n === 1){ return 1; } if(!memo[n]){ memo[n] = fib_memo(n-1) + fib_memo(n - 2) } return memo[n];};console.time('time');let res = fib_memo(10);console.timeEnd('time')console.log('res:', res, 'count:', count); 时间复杂度：O(n) 空间复杂度：O(n) 虽然时间复杂度度大大降低了，但这仍然影响性能。 因为在程序调用一个函数时，栈中会分配一块空间来保存与这个调用相关的信息，每一个调用都会被当作是活跃的。栈上的那块存储空间称为活跃记录或者栈帧。 然后因为递归函数在调用的时候会不断的创建一个栈帧来保存上一个函数的调用信息，栈上的栈帧越来越多，就会导致爆栈 Maximum call stack size exceeded。 接下来的目的就是去优化函数的调用栈，下面介绍尾递归。 优化方式二：尾递归如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的 下面几种情况都不是尾递归： 123456789101112function fn() { return gn() + 10//调用之后又赋值}function fn() { gn()//没有return，或者说是return了undefined}function fn() { let gnn = gn(); return gnn//调用后还有操作} 当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。 编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。 通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。 123456789101112131415161718// 尾递归let count = 0;const fib_tail = (n, num = 1, sum = 1) =&gt; { console.trace() count++; if (n&lt;=1){ return sum; } return fib_tail(n-1, sum, num + sum);}console.time('time');let res = fib_tail(10);console.timeEnd('time')console.log('res:', res, 'count:', count); 时间复杂度： O(n)空间复杂度： O(1) 可以看到此时这个算法的效率已经非常高了，但这仍然不是最优解，因为存在函数的调用开销，下面开始介绍动态规划算法。 动态规划算法动态规划算法（Dynamic Programming）与分治算法相似，都是通过组合子问题的解来求解原问题的解。 但是两者之间也有很大区别：分治法将问题划分为互不相交的子问题，递归的求解子问题，再将他们的解组合起来求解原问题的解；与之相反，动态规划应用于子问题相互重叠的情况，在这种情况下，分治法还是会做很多重复的不必要的工作，他会反复求解那些公共的子问题，而动态规划算法则对相同的每个子问题只会求解一次，将其结果保存起来，避免一些不必要的计算工作 特征 大问题可以分为若干规模小的相同问题。//即要求具有最优子结构性质 子问题空间必须足够” 小 “，也就是说原问题递归求解时会重复相同的子问题，而不是一直生成新的子问题。 //即有重叠子问题 思考步骤： 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。(划分子问题) 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。(状态表示) 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。（子问题与下个子问题间的关系式） 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。（边界条件） 比如斐波那契数列：1 1 2 3 5 8 13 21 … ，求第n项的值 第一步：输入1，输出1；输入2，输出1；输入3，输出2，通过分析可知道第n项值等于第n-1和n-2项的和 第二步：最后一项为f(n)，两项分别为f(n-1)、f(n-2) 第三步：状态转移方程：dp(n) = dp(n-1) + dp(n-2) 第四步：边界条件为dp[1]=1, dp[2]=1 1234567891011121314151617181920// 不带缓存的dplet count = 0;const fib_dp_unmemo = (n) =&gt; { let dp = []; dp[0] = 0; dp[1] = 1; for(let i = 2; i &lt;= n; i++) { count++; dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n];}console.time('time')let res = fib_dp_unmemo(30)console.timeEnd('time')console.log('res:', res, 'count:', count); 此时时间复杂度为O(n), 空间复杂度为O(n)，这还不够优雅，因为空间消耗的也多 123456789101112131415// 带缓存的dpconst fib_dp_memo = (n) =&gt; { let front = 0; let back = 1; let res = 0; for(let i = 2; i &lt;= n; i++) { res = front + back; front = back; back = res; } return res;};let res = fib_dp_memo(30); 使用变量保存下一次循环需要的子问题结果，而不是保存全部结果，这样能大大减少内存 此时时间复杂度为O(n), 空间复杂度为O(1) 动态规划对比于尾递归，通过一次迭代得到结果，函数的调用开销减少了，同时时空间复杂度和尾递归相同，是解决这个问题的最优解！ 拓展leetcode 题号：198.打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统， 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 1 &lt;= nums.length &lt;= 1000 &lt;= nums[i] &lt;= 400 首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。 如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。 如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？ 对于第 k (k&gt;2) 间房屋，有两个选项： 偷窃第 k 间房屋，那么就不能偷窃第 k-1 间房屋，偷窃总金额为前 k-2 间房屋的最高总金额与第 k 间房屋的金额之和。 不偷窃第 k 间房屋，偷窃总金额为前 k-1 间房屋的最高总金额。 在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。 用 dp[i] 表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程： dp[i] = max(dp[i−2] + nums[i], dp[i−1]) 边界条件为：dp[0] = nums[0] //只有一间房屋，则偷窃该房屋dp[1] = max(nums[0], nums[1]) //只有两间房屋，选择其中金额较高的房屋进行偷窃 12345678910111213const rob = (nums) =&gt; { const len = nums.length; if(len == 0){ return 0; } const dp = new Array(len + 1); dp[0] = 0; dp[1] = nums[0]; for(let i = 2; i &lt;= len; i++) { dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]); } return dp[len];}; 还不够，进行空间优化 123456789101112131415const rob = (nums) =&gt; { const len = nums.length; if(len == 0){ return 0; } let front = 0; let back = nums[0]; let res = 0; for(let i = 2; i &lt;= len; i++) { res = Math.max(back, front + nums[i-1]); front = back; back = res; } return res;};","link":"/2021/09/22/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5&%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"antd动态主题","text":"零代码本地会保存一份antd全部样式变量的文件","link":"/2022/02/28/antd%E5%8A%A8%E6%80%81%E4%B8%BB%E9%A2%98/"},{"title":"antd table 滚动加载","text":"背景最近在工作中有一个列表的滚动加载功能需求，了解了一下发现antd的table是不支持滚动加载的，只有list支持。因为原来的业务代码是用table做的，为了不改变原来的代码，我打算自己写个table的滚动加载功能。 实现想要实现一个滚动加载，目标就是实现对table的滚动行为进行监听。第一个想法就是获取Table的dom，然后对可滚动的table-body添加一个监听事件，这里我们利用useRef来获取dom。出现问题了，会报错，ts提示我们不能将MutableRefObject这个类型传递到table的props中。 12345678const target = useRef(null);&lt;Table ref={target} dataSource={dataSource} columns={columns} loading={tableLoading} scroll={{ y: 200 }}/&gt; 既然Table不能传入ref，那在外面包一层div总行了吧，于是代码变成了这样 123456789const target = useRef(null);&lt;div ref={target}&gt; &lt;Table dataSource={dataSource} columns={columns} loading={tableLoading} scroll={{ y: 200 }} /&gt;&lt;/div&gt; 控制台打印一下target.current，可以获取dom对象，到这我们的第一步目的就达成了。 接下来我们在target.current中获取table-body的dom对象，并对table-body的滚动进行监听，然后通过条件crollHeight - scrollTop === clientHeight来判断滚动条是否滚到底了，滚到底了就去异步加载数据。完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import React, { useEffect, useState, useRef } from 'react';import { Table } from 'antd';const data = [ { key: '1', name: '胡彦斌', age: 1, address: '西湖区湖底公园1号', }, { key: '2', name: '胡彦祖', age: 2, address: '西湖区湖底公园1号', }, { key: '3', name: '胡彦斌', age: 3, address: '西湖区湖底公园1号', }, { key: '4', name: '胡彦祖', age: 4, address: '西湖区湖底公园1号', }, { key: '5', name: '胡彦斌', age: 5, address: '西湖区湖底公园1号', }, { key: '6', name: '胡彦祖', age: 6, address: '西湖区湖底公园1号', },];const columns = [ { title: '姓名', dataIndex: 'name', key: 'name', }, { title: '年龄', dataIndex: 'age', key: 'age', }, { title: '住址', dataIndex: 'address', key: 'address', },];const ScrollTable = () =&gt; { const [dataSource, setDataSource] = useState(data); const [tableLoading, setTableLoading] = useState(false); const target = useRef(null); useEffect(() =&gt; { const dom = (target.current as HTMLElement | null)?.querySelector( '.ant-table-body', ) as HTMLElement; dom.addEventListener('scroll', () =&gt; scrollEvent()); return () =&gt; { dom.removeEventListener('scroll', scrollEvent); }; }, []); const scrollEvent = () =&gt; { const dom = (target.current as HTMLElement | null)?.querySelector( '.ant-table-body', ) as HTMLElement; if (dom.scrollHeight - dom.scrollTop === dom.clientHeight) { // 在这里去获取并更新数据 setTableLoading(true); setTimeout(() =&gt; { console.log('已滚动到底部'); let arr: any = []; setDataSource(arr); setTableLoading(false); }, 1000); } }; return ( &lt;div ref={target} style={{ width: '70%', margin: 'auto', paddingTop: '100px' }} &gt; &lt;Table dataSource={dataSource} columns={columns} loading={tableLoading} scroll={{ y: 200 }} /&gt; &lt;/div&gt; );};export default ScrollTable;","link":"/2021/09/22/antd%20table%20%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD/"},{"title":"手写call和apply","text":"原文链接 一句话介绍 call：call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 举个例子： 123456789var foo = { value: 1};function bar() { console.log(this.value);}bar.call(foo); // 1 注意两点： call 改变了 this 的指向，指向到 foo bar 函数执行了 模拟实现第一步那么我们该怎么模拟实现这两个效果呢？ 试想当调用 call 的时候，把 foo 对象改造成如下： 12345678var foo = { value: 1, bar: function() { console.log(this.value) }};foo.bar(); // 1 这个时候 this 就指向了 foo，是不是很简单呢？ 但是这样却给 foo 对象本身添加了一个属性，这可不行呐！ 不过也不用担心，我们用 delete 再删除它不就好了~ 所以我们模拟的步骤可以分为： 将函数设为对象的属性 执行该函数 删除该函数 以上个例子为例，就是： 123456// 第一步foo.fn = bar// 第二步foo.fn()// 第三步delete foo.fn fn 是对象的属性名，反正最后也要删除它，所以起成什么都无所谓。 根据这个思路，我们可以尝试着去写第一版的 call2 函数： 123456789101112131415161718// 第一版Function.prototype.call2 = function(context) { // 首先要获取调用call的函数，用this可以获取 context.fn = this; context.fn(); delete context.fn;}// 测试一下var foo = { value: 1};function bar() { console.log(this.value);}bar.call2(foo); // 1 正好可以打印 1 哎！是不是很开心！(～￣▽￣)～ 模拟实现第二步最一开始也讲了，call 函数还能给定参数执行函数。举个例子： 1234567891011121314var foo = { value: 1};function bar(name, age) { console.log(name) console.log(age) console.log(this.value);}bar.call(foo, 'kevin', 18);// kevin// 18// 1 注意：传入的参数并不确定，这可咋办？ 不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。 比如这样： 1234567891011121314// 以上个例子为例，此时的arguments为：// arguments = {// 0: foo,// 1: 'kevin',// 2: 18,// length: 3// }// 因为arguments是类数组对象，所以可以用for循环var args = [];for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push('arguments[' + i + ']');}// 执行后 args为 [&quot;arguments[1]&quot;, &quot;arguments[2]&quot;, &quot;arguments[3]&quot;] 不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。 1234// 将数组里的元素作为多个参数放进函数的形参里context.fn(args.join(','))// (O_o)??// 这个方法肯定是不行的啦！！！ 也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到ES6的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样： 1eval('context.fn(' + args +')') 这里 args 会自动调用 Array.toString() 这个方法。 所以我们的第二版克服了两个大问题，代码如下： 1234567891011121314151617181920212223242526// 第二版Function.prototype.call2 = function(context) { context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push('arguments[' + i + ']'); } eval('context.fn(' + args +')'); delete context.fn;}// 测试一下var foo = { value: 1};function bar(name, age) { console.log(name) console.log(age) console.log(this.value);}bar.call2(foo, 'kevin', 18); // kevin// 18// 1 (๑•̀ㅂ•́)و✧ 模拟实现第三步模拟代码已经完成 80%，还有两个小点要注意： this 参数可以传 null，当为 null 的时候，视为指向 window 举个例子： 1234567var value = 1;function bar() { console.log(this.value);}bar.call(null); // 1 虽然这个例子本身不使用 call，结果依然一样。 函数是可以有返回值的！ 举个例子： 123456789101112131415161718var obj = { value: 1}function bar(name, age) { return { value: this.value, name: name, age: age }}console.log(bar.call(obj, 'kevin', 18));// Object {// value: 1,// name: 'kevin',// age: 18// } 不过都很好解决，让我们直接看第三版也就是最后一版的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// 第三版Function.prototype.call2 = function (context) { var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push('arguments[' + i + ']'); } var result = eval('context.fn(' + args +')'); delete context.fn return result;}// 测试一下var value = 2;var obj = { value: 1}function bar(name, age) { console.log(this.value); return { value: this.value, name: name, age: age }}bar.call2(null); // 2console.log(bar.call2(obj, 'kevin', 18));// 1// Object {// value: 1,// name: 'kevin',// age: 18// } 到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣▽￣）ｄ 代码有点老了，用ES6语法再完善一下吧1234567891011Function.prototype.call2 = function (context, ...args) { if (context == null) target = globalThis; if (typeof context !== 'object') context = Object(context); const symbol = Symbol(); context[symbol] = this; try { return context[symbol](...args); } finally { delete context[symbol]; }} apply的模拟实现apply 的实现跟 call 类似，在这里直接给代码: 12345678910111213141516171819Function.prototype.apply = function (context, arr) { var context = Object(context) || window; context.fn = this; var result; if (!arr) { result = context.fn(); } else { var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) { args.push('arr[' + i + ']'); } result = eval('context.fn(' + args + ')') } delete context.fn return result;}","link":"/2022/11/11/%E6%89%8B%E5%86%99call%E5%92%8Capply/"},{"title":"手写bind","text":"一句话介绍 bindbind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 由此我们可以首先得出 bind 函数的两个特点： 返回一个函数 h可以传入参数","link":"/2022/11/11/%E6%89%8B%E5%86%99bind/"},{"title":"DNS域名解析全过程","text":"目的将域名地址解析成可以访问的ip地址 流程输入网址 ↓浏览器缓存 ↓本地DNS缓存 ↓LDNS(本地域名服务器) ↓Root Server(根域名服务器) ↓返回主域名服务器地址（gTLD Server，国际顶尖域名服务器，如.com .cn .org等） ↓LDNS请求gTLD，返回Name Server域名服务器地址 ↓Name Server根据映射关系返回ip地址给LDNS ↓LDNS缓存域名和ip，返回结果给用户 ↓用户侧缓存域名和ip ↓解析结束","link":"/2022/11/27/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"title":"TCP三次握手和四次挥手","text":"三次握手SYN = 1, seq = j=&gt;SYN = 1, ACK = 1, ack = j + 1, seq = k=&gt;ACK = 1, ack = k + 1 第一次握手：客户端将TCP报文标志位SYN置为1，随机产生一个序号值seq=J，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入SYN_SENT状态，等待服务器端确认。 第二次握手：服务器端收到数据包后由标志位SYN=1表示知道客户端请求建立连接，同时将标志位SYN和ACK都置为1，确认号ack=J+1，随机产生一个序号值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。 第三次握手：客户端收到确认后，检查确认号ack是否为J+1，标志位ACK是否为1，如果正确则将标志位ACK置为1，确认号ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了 注意:我们上面写的ack和ACK，不是同一个概念： 小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，ack=seq+1。 大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。 四次挥手第一次挥手：Client端发起挥手请求，并且停止发送数据，向Server端发送标志位是FIN报文段，FIN=1，设置序列号seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，Client端进入FIN_WAIT_1（终止等待1）状态，这表示Client端没有数据要发送给Server端了（TCP规定，FIN报文段即使不携带数据，也要消耗一个序号） 第二次挥手：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK=1的报文段，ack设为seq加1（u+1），并且带上自己的序列号seq=v，服务端就进入了CLOSE-WAIT（关闭等待）状态，TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 第三次挥手：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 第四次挥手：客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端依然没有收到回复，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。可以看到，服务器结束TCP连接的时间要比客户端早一些。 常见面试题【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？ 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。所以建立连接只需要三次握手。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 【问题3】为什么需要三次握手？为什么不能用两次握手进行连接？ 答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 如果使用两次握手就建立连接，就会出现出现以下情况： 我们假设client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设采用“两次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下（第二次握手丢失），将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。","link":"/2022/11/28/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"title":"React Fiber","text":"在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，递归更新时间超过了16ms，用户交互就会卡顿。 为了解决这个问题，React16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。于是，全新的Fiber架构应运而生。 那么如何理解react中的fiber呢，两个层面来解释： 从运行机制上来解释，fiber是一种流程让出机制，它能让react中的同步渲染进行中断，并将渲染的控制权让回浏览器，从而达到不阻塞浏览器渲染的目的。 从数据角度来解释，fiber能细化成一种数据结构，或者一个执行单元。 react会在跑完一个执行单元后检测自己还剩多少时间（这个所剩时间下文会解释），如果还有时间就继续运行，反之就终止任务并记录任务，同时将控制权还给浏览器，直到下次浏览器自身工作做完，又有了空闲时间，便再将控制权交给react，以此反复。 每一个被创建的虚拟dom都会被包装成一个fiber节点，他具有如下结构： 123456const fiber = { stateNode, // dom节点实例 child, // 当前节点所关联的子节点 sibling, // 当前节点所关联的兄弟节点 return // 当前节点所关联的父节点} react中的fiber其实具备如下几点核心特点： 支持增量渲染，fiber将react中的渲染任务拆分到每一帧。（不是一口气全部渲染完，走走停停，有时间就继续渲染，没时间就先暂停） 支持暂停，终止以及恢复之前的渲染任务。（没渲染时间了就将控制权让回浏览器） 通过fiber赋予了不同任务的优先级。（让优先级高的运行，比如事件交互响应，页面渲染等，像网络请求之类的往后排） 支持并发处理（结合第3点理解，面对可变的一堆任务，react始终处理最高优先级，灵活调整处理顺序，保证重要的任务都会在允许的最快时间内响应，而不是死脑筋按顺序来） 在一些极端情况下，浏览器会最多给出50ms的空闲时间给我们处理想做的事情，比如我们一些任务非常耗时，浏览器知道我们会耗时，但为了让页面呈现尽可能不要太卡顿，同时又要照顾JS线程，所以它会主动将一帧的用时从16.66ms提升到50ms，也就是说此时1S浏览器至多能渲染20帧 react在最终实现上并未直接采用requestIdleCallback，一方面是requestIdleCallback目前还是实验中的api，兼容性不是非常好，其次考虑到剩余时间提升到50ms也就20帧左右，体验依旧不是很好。于是react通过MessageChannel + requestAnimationFrame 自己模拟实现了requestIdleCallback 当前帧结束时间： 我们知道requestAnimationFrame的回调被执行的时机是当前帧开始绘制之前。也就是说rafTime是当前帧开始时候的时间，如果按照每一帧执行的时间是16.66ms。那么我们就能算出当前帧结束的时间， frameDeadline = rafTime + 16.66。 当前帧剩余时间：当前帧剩余时间 = 当前帧结束时间(frameDeadline) - 当前帧花费的时间。关键是我们怎么知道’当前帧花费的时间’，这个是怎么算的，这里就涉及到js事件循环的知识。react中是用MessageChannel实现的。 1234567891011121314151617181920212223242526272829303132333435363738let frameDeadline // 当前帧的结束时间let penddingCallback // requestIdleCallback的回调方法let channel = new MessageChannel()// 当执行此方法时，说明requestAnimationFrame的回调已经执行完毕，此时就能算出当前帧的剩余时间了，直接调用timeRemaining()即可。// 因为MessageChannel是宏任务，需要等主线程任务执行完后才会执行。我们可以理解requestAnimationFrame的回调执行是在当前的主线程中，只有回调执行完毕onmessage这个方法才会执行。// 这里可以根据setTimeout思考一下，setTimeout也是需要等主线程任务执行完毕后才会执行。channel.port2.onmessage = function() { // 判断当前帧是否结束 // timeRemaining()计算的是当前帧的剩余时间 如果大于0 说明当前帧还有剩余时间 let timeRema = timeRemaining() if(timeRema &gt; 0){ // 执行回调并把参数传给回调 penddingCallback &amp;&amp; penddingCallback({ // 当前帧是否完成 didTimeout: timeRema &lt; 0, // 计算剩余时间的方法 timeRemaining }) }}// 计算当前帧的剩余时间function timeRemaining() { // 当前帧结束时间 - 当前时间 // 如果结果 &gt; 0 说明当前帧还有剩余时间 return frameDeadline - performance.now()}window.requestIdleCallback = function(callback) { requestAnimationFrame(rafTime =&gt; { // 算出当前帧的结束时间 这里就先按照16.66ms一帧来计算 frameDeadline = rafTime + 16.66 // 存储回调 penddingCallback = callback // 这里发送消息，MessageChannel是一个宏任务，也就是说上面onmessage方法会在当前帧执行完成后才执行 // 这样就可以计算出当前帧的剩余时间了 channel.port1.postMessage('haha') // 发送内容随便写了 })} 那么到这里，我们阐述了react 15以及之前的大量dom渲染时卡顿的原因，从而介绍了帧的概念。 紧接着我们引出了fiber，那么什么是fiber呢？往小了说它就是一种数据结构，包含了任务开始时间，节点关系信息（return,child这些），我们把视角往上抬一点，我们也可以说fiber是一种模拟调用栈的特殊链表，目的是为了解决传统调用栈无法暂停的问题。 而站在宏观角度fiber又是一种调度让出机制，它让react达到了增量渲染的目的，在保证帧数流畅的同时，fiber总是在浏览器有剩余时间的情况下去完成目前目前最高优先级的任务。 所以如果让我来提炼fiber的关键词，我大概给出如下几点： fiber是一种数据结构。 fiber使用父子关系以及next的妙用，以链表形式模拟了传统调用栈。 fiber是一种调度让出机制，只在有剩余时间的情况下运行。 fiber实现了增量渲染，在浏览器允许的情况下一点点拼凑出最终渲染效果。 fiber实现了并发，为任务赋予不同优先级，保证了一有时间总是做最高优先级的事，而不是先来先占位死板的去执行。 fiber有协调与提交两个阶段，协调包含了fiber创建与diff更新，此过程可暂停。而提交必须同步执行，保证渲染不卡顿。 而通过fiber的协调阶段，我们了解了diff的对比过程，如果将fiber的结构理解成一棵树，那么这个过程本质上还是深度遍历，其顺序为父—父的第一个孩子—孩子的每一个兄弟。 通过源码，我们了解到react的diff是同层比较，最先比较key，如果key不相同，那么不用比较剩余节点直接删除，这也强调了key的重要性，其次会比较元素的type以及props。而且这个比较过程其实是拿旧的fiber与新的虚拟dom在比，而不是fiber与fiber或者虚拟dom与虚拟dom比较，其实也不难理解，如果key与type都相同，那说明这个fiber只用做简单的替换，而不是完整重新创建，站在性能角度这确实更有优势。 最后，附上fiber更新调度的执行过程：","link":"/2022/12/05/React-Fiber/"}],"tags":[],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"业务","slug":"业务","link":"/categories/%E4%B8%9A%E5%8A%A1/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"手写源码","slug":"手写源码","link":"/categories/%E6%89%8B%E5%86%99%E6%BA%90%E7%A0%81/"},{"name":"网络","slug":"网络","link":"/categories/%E7%BD%91%E7%BB%9C/"},{"name":"React","slug":"React","link":"/categories/React/"}]}